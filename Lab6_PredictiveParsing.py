# Lab 6: Predictive Parsing Table Construction (LL(1))
# Compiler Design Lab
# Author: Dhaswini V

from collections import defaultdict

grammar = defaultdict(list)
first = defaultdict(set)
follow = defaultdict(set)
non_terminals = set()
terminals = set()

# Function to check terminal
def is_terminal(symbol):
    return symbol not in non_terminals and symbol != 'ε'

# FIRST computation
def compute_first(symbol):
    if symbol in first and first[symbol]:
        return first[symbol]

    if is_terminal(symbol):
        first[symbol].add(symbol)
        return first[symbol]

    for production in grammar[symbol]:
        if production == 'ε':
            first[symbol].add('ε')
            continue

        for char in production:
            char_first = compute_first(char)
            first[symbol].update(char_first - {'ε'})
            if 'ε' not in char_first:
                break
        else:
            first[symbol].add('ε')

    return first[symbol]

# FOLLOW computation
def compute_follow(start_symbol):
    follow[start_symbol].add('$')

    changed = True
    while changed:
        changed = False
        for lhs in grammar:
            for production in grammar[lhs]:
                for i, symbol in enumerate(production):
                    if symbol in non_terminals:
                        next_part = production[i+1:]

                        if next_part:
                            temp_first = set()
                            for nxt in next_part:
                                nxt_first = compute_first(nxt)
                                temp_first.update(nxt_first - {'ε'})
                                if 'ε' not in nxt_first:
                                    break
                            else:
                                temp_first.update(follow[lhs])
                        else:
                            temp_first = follow[lhs]

                        before = len(follow[symbol])
                        follow[symbol].update(temp_first)
                        if len(follow[symbol]) != before:
                            changed = True

# Construct Parsing Table
def construct_parsing_table():
    table = defaultdict(dict)

    for nt in grammar:
        for production in grammar[nt]:
            prod_first = set()

            if production == 'ε':
                prod_first.add('ε')
            else:
                for symbol in production:
                    symbol_first = compute_first(symbol)
                    prod_first.update(symbol_first - {'ε'})
                    if 'ε' not in symbol_first:
                        break
                else:
                    prod_first.add('ε')

            # Fill table using FIRST
            for terminal in prod_first - {'ε'}:
                table[nt][terminal] = f"{nt}->{production}"

            # If epsilon in FIRST, use FOLLOW
            if 'ε' in prod_first:
                for f in follow[nt]:
                    table[nt][f] = f"{nt}->ε"

    return table

# Input grammar
n = int(input("Enter number of productions: "))
print("Enter productions in format A->aB|b (No spaces):")

for _ in range(n):
    prod = input().strip()
    lhs, rhs = prod.split("->")
    non_terminals.add(lhs)
    alternatives = rhs.split("|")
    for alt in alternatives:
        grammar[lhs].append(alt)

# Identify terminals
for lhs in grammar:
    for production in grammar[lhs]:
        for symbol in production:
            if symbol not in non_terminals and symbol != 'ε':
                terminals.add(symbol)

terminals.add('$')

# Compute FIRST sets
for nt in non_terminals:
    compute_first(nt)

# Compute FOLLOW sets
start_symbol = list(grammar.keys())[0]
compute_follow(start_symbol)

# Construct Parsing Table
parsing_table = construct_parsing_table()

# Display FIRST
print("\nFIRST Sets:")
for nt in sorted(non_terminals):
    print(f"FIRST({nt}) = {{ {', '.join(sorted(first[nt]))} }}")

# Display FOLLOW
print("\nFOLLOW Sets:")
for nt in sorted(non_terminals):
    print(f"FOLLOW({nt}) = {{ {', '.join(sorted(follow[nt]))} }}")

# Display Parsing Table
print("\nPredictive Parsing Table (LL(1)):\n")
terminals_list = sorted(terminals)

# Header
print(f"{'NT/T':<8}", end="")
for t in terminals_list:
    print(f"{t:<10}", end="")
print()

# Table rows
for nt in sorted(non_terminals):
    print(f"{nt:<8}", end="")
    for t in terminals_list:
        entry = parsing_table[nt].get(t, "")
        print(f"{entry:<10}", end="")
    print()
